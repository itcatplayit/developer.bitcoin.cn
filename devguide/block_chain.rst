区块链
===========

区块链为比特币提供了一个公共账本，按照顺序和时间戳记录交易。该系统可以防止双花和更改历史交易。

介绍
------------


比特币 `网络 <../devguide/p2p_network.html>`__ 中的每个全节点独立存储的区块链只包含该节点已经验证过的区块。当几个节点在它们的区块链中都包含了同一个区块，此时认为它们 :term:`达成一致 <Consensus>` 。节点之间为了保证一致性所遵循的验证规则别称为 :term:`一致性原则 <Consensus rules>` 。本节将讨论比特币核心使用的多种一致性原则。

.. figure:: /img/dev/en-blockchain-overview.svg
   :alt: 区块链纵览

   区块链纵览

上图示意了一个简单版本的区块链。每个 :term:`区块 <Block>` 中包含的一个或多个交易放置在区块的数据区。每笔交易副本被哈希，然后哈希值被配对，被哈希，再次被配对，再次被哈希直到只剩下最后一个哈希，该哈希称为默克尔树(Merkle tree)的 :term:`默克尔根(Merkle root) <Merkle root>` 。

默克尔根保存在区块的头部。每个区块头部还包含前一个区块的头hash，这样就将区块链接起来（前向链表）。这样可以保证交易在不修改后续节点的情况下无法修改当前节点的内容。

交易也是被链接在一起。比特币钱包给人的印象是1 聪（satoshis，比特币最小单位，1 聪等于0.00000001比特币）比特币从一个钱包到另一个钱包，但是实际上比特币是从一个交易到另一个交易。每个交易花费之前接收到的一个或多个交易的币，因此一个交易的输入是之前另一个交易的输出。

.. figure:: /img/dev/en-transaction-propagation.svg
   :alt: 交易传播图

   交易传播图

在将交易结果分送多个地址的情形下，一个交易可以产生多个输出，但是一个指定的交易输出只能在整条链中作为输入一次。后续任何的引用都会由于禁止双花导致失败。

输出和 :term:`交易标志符 (TXIDs) <Txid>` 绑定，它是交易的签名。

由于每个输出只能被花费一次，因此区块链中所有的输出可以分为两类： :term:`未花费的输出 (UTXOs) <UTXO>` 和已花费的输出。一个有效的交易，必须使用UTXOs作为输入。

除了基础币交易（后续详述）外，如果交易的输出值大于交易的输入值，这个交易会被拒绝；但是，如果交易的输入值大于交易的输出值，二者的差值则作为 :term:`交易费用 <Transaction fee>` 被挖出包含该交易区块的 :term:`矿工 <Mining>` 占有。举例来说，上图显示的每个交易的输出都比输入少10,000 聪，缺少的部分就是作为交易费用的部分。

工作量证明
-------------

区块链在 `网络 <../devguide/p2p_network.html>`__ 上被匿名节点协作保存，因此比特币要求每个区块都投入一定工作量才能生成，以此来确保不可靠节点想要修改历史块就不得不比那些只想往区块链上添加新块的诚实节点付出更多的努力。

链在一起的区块可以保证，如果不更新指定区块的所有后续区块，则无法更新该区块中的交易。因此，更新一个特定区块的代价随着新区块的增加而增加，同时放大了工作量证明的作用。

:term:`工作量证明 <Proof of work>` 利用了密码学哈希结果明显的随机特性。一个好的哈希算法将任意的数据转换成看起来随机的数字。如果输入数据的发生任何的变动，哈希过程重新执行，一个新的随机数就会产生，因此无法通过更新输入数据有目的的预测哈希结果。

为了证明节点为了生成区块做了一定的工作，节点必须产生出一个哈希结果不超出指定值的区块头部。比如，如果最大的可能的哈希值的个数为2256-1，可以证明节点平均尝试2次就可以产生一个哈希值小于2255的头部。

在上面的例子中，节点几乎每个一次就可以成功一次。同时可以根据指定的 :term:`目标 <nBits>` 门槛，估计一次哈希尝试成功的概率。比特币假定门槛和成功概率是线性关系，门槛越低，平均需要的尝试次数越多。

只有当区块的哈希值满足一致性协议指定的 :term:`难度 <Difficulty>` 值时，该区块才会被加入到区块链中。每隔2,016个区块， `网络 <../devguide/p2p_network.html>`__ 利用存储在每个区块头中的时间戳计算产生这2,016各区块的时间间隔。该间隔的理想值为1,209,600秒(两周)。

- 如果生成2,016个区块花费的实际的间隔小于2周，则期望的难度值会按比例上升（最高300%），由此下一批2,016个区块按相同速率产生，则刚好花费2周的时间。

- 同理，如果实际的间隔大于2周，期望的难度值则会按比例下降（最低到75%）。

（注意：比特币核心实现中的一个一偏移错误导致使用仅2,01\ *5* 个块的时间戳每2,01\ *6* 个块更新一次，从而产生轻微的偏差。）

由于每个哈希头都要满足指定的难度值，而且每个区块都会链接它前面的区块，因此更新一个区块（平均来讲）需要付出从该区块创造到当前时刻区块链整体 `网络 <../devguide/p2p_network.html>`__ 算力的总和。因此只有你获得了了 `网络 <../devguide/p2p_network.html>`__ 的大部分算力，才能够可靠的进行51%攻击修改交易历史（但是，需要指出的是，即使少于50%的算力，仍然有很大可能性进行这种攻击）。

区块头部中提供了几个容易更新的字段，比如专门的nonce字段，因此获取新的哈希值并不一定要等待新的交易。同时，只需要对80字节的区块头进行哈希，因此在区块中包含大量的交易不会降低哈希的效率，增加新的交易只需要重算默克尔树。

块高和分叉
------------------------

所有成功挖到新块的矿工都可以把他们的新块添加到区块链中（假定这些区块都是有效的）。这些区块通过它们的 :term:`区块高度 <Block height>` ————当前区块到初始区块（区块0，或者说更有名的称为 :term:`创世块 <Genesis block>`）的区块个数 进行定位。例如，2016是第一个进行难度调整的区块。

.. figure:: /img/dev/en-blockchain-fork.svg
   :alt: 通常区块分叉与罕见区块分叉

   通常区块分叉与罕见区块分叉

由于多个矿工可能几乎同时挖到新区块，因此可能存在多个区块拥有相同区块高度。这种情况下就在区块链中产生了明显的 :term:`分叉 <Fork>` ，如上图所示。

当几个矿工同时生产出区块，每个节点独立的判断选择接受哪个，在没有其他考虑的情况下，节点通常选择接受他们看到的第一个区块。

最终，一个矿工生产出来了一个区块，它附在了几条并行区块分叉中的一条。这时这条区块就比其他区块更有优势。假设一个分叉只包含有效的区块，正常的节点通常会跟随难度最大的区块继续工作，抛弃其他分叉上的 :term:`失效块 <Stale block>`。（失效块也有时叫孤立块或孤儿区块，但这些术语也用于没有已知父块的真正孤立块。）

如果不同的矿工出于相反目的工作，例如一些矿工努力扩展区块链，而其他矿工则试图通过51%的攻击来修改交易历史，那么长期分叉是可能的。

由于可能存在多个分叉，因此区块高度不能作为区块的唯一标识。而是使用头部的哈希值（通常进行字节顺序反转，并用16进制表示）。

交易数据
----------------

每个区块中必须包含一笔到多笔交易。这些交易中的第一笔都是币基础交易，或被称为生成交易，负责搜集和支付区块奖励（包括块补贴和包含在该块中的交易的手续费）。

币基础交易的UTXO有一个特殊条件，即它不能被花费（用作输入）至少100个块。这暂时防止了矿工从区块链分叉后可能被确定为过时无效的区块（因此coinbase交易被破坏）中花费交易费用和区块奖励。

区块当中并不强制要求一定有非生成交易，但是矿工为了获取交易手续费通常会包含额外的交易。

包含生成交易在内的所有交易，都被编码为二进制原始交易格式包含在区块中。

二进制原始交易格式通过hash产生一个交易标志TXIS，Merkle树算法把这些交易组成一对，然后把他们hash在一起，如果这里有奇数各txid，没有txid的交易将会和自己的复制镜像配对；hash的结果之间继续进行配对hash，单独的结果还是和自己配对，这样依次递归，知道剩下唯一的hash结果，Merkle根。

对原始交易格式进行哈希运算以创建交易标识符（txid）。根据这些txid，通过将每个txid与另一个txid配对，然后将它们哈希在一起，来构建 :term:`默克尔树 <Merkle tree>`。如果存在奇数个txid，则单独的txid将使用其自身的副本进行哈希运算。

生成的哈希本身分别与另一个哈希配对并哈希运算在一起。任何哈希如果没有配对就和它自己进行哈希运算。这个过程持续到仅剩一个哈希，就是默克尔根。

例如，如果交易只是被加入（而不是哈希运算），一个包含5个交易的默克尔树生成过程如下：

::

          ABCDEEEE .......默克尔根
         /        \
      ABCD        EEEE
     /    \      /
    AB    CD    EE .......E和自身配对
   /  \  /  \  /
   A  B  C  D  E .........交易

正如在简化支付验证（SPV）一节讲到的，默克尔树允许客户端通过向相邻完全节点请求区块头部的默克尔根和一系列的中间哈希结果来自己验证交易是否包含在指定区块中。相邻完全节点不一定必须是可信任节点：伪造节点头部是昂贵的，并且中间哈希不能伪造，否则验证将失败。

举例来说，如上图所示，为了验证交易D在区块中，SPV端除了需要默克尔根外，只需要C，以及AB、EEEE哈希的拷贝，此外再不需要知道其他交易的任何内容。如果区块中的这5个交易都达到限定的最大值，那么下载该区块需要超过 500,000 字节，而下载3个哈希值和一个头部仅需要140字节。

注意：如果在同一个块中发现相同的txid，则默克尔树可能会与删除了部分或所有重复项的块发生冲突，这是由于默克尔树的实现方式不平衡（复制单独的哈希）。由于使用相同的txid进行单独的交易是不切实际的，这不会给诚实的节点带来负担，但如果要缓存块的无效状态，则必须进行检查；否则，一个去除重复的有效节点可能和另一个节点有相同的默克尔树和块哈希值，但是因缓存的无效交易被拒绝，导致诸如 `CVE-2012-2459 <https://en.bitcoin.it/wiki/CVEs#CVE-2012-2459>`__ 的安全问题。

共识规则改变
----------------------

为了保持一致性，所有的全节点使用相同的一致性规则确认区块的有效性。但是，有时在引入新特性或防止 `网络 <../devguide/p2p_network.html>`__ 滥用时会导致一致性规则的变化。当新的规则实施时，存在一个遵守新旧规则的节点同时存在的时期，此时有两种打破一致性的可能：

1. 一个符合新规则的区块被新的节点接受，但是不能被老的节点接受。比如，区块中使用了新的交易特性，升级的节点理解该特性，并接受它，但是老的节点按照旧规则判断一致性失败拒绝该区块。

2. 一个违反新规则的区块被新节点拒绝，但是会被老的节点接受。比如，一个滥用交易的特性在就区块中，该区块被新节点拒绝，但是被老节点接受。

在第一种情况下，被未升级节点拒绝，从旧节点接受数据的挖矿软件拒绝和从新节点接收数据的挖矿软件工作在相同的区块链。这会产生永久的分歧链，一个针对未升级的节点，一个针对已升级的节点，这被称为 :term:`硬分叉 <Hard fork>`。

.. figure:: /img/dev/en-hard-fork.svg
   :alt: 硬分叉

   硬分叉

在第二种情况下，被升级的节点拒绝，如果升级的节点控制了大部分哈希率，则可以防止块链永久分叉。这是因为，在这种情况下，未升级的节点将接受与升级的节点相同的所有块作为有效块，因此升级的节点可以建立一个更强的链，未升级节点将接受该链作为最佳有效块链。这被称为：:term:`软分叉 <Soft fork>`。


.. figure:: /img/dev/en-soft-fork.svg
   :alt: 软分叉

   软分叉

尽管分叉表示对区块链实际的分裂，但是对一致性规则的改变通常还是会用潜在产生硬分叉或软分叉进行描述。比如“增加区块大小超过1MB需要一次硬分叉”，该例中，并不是真正需要一次区块链的分叉，只是可能而已。

一致性规则的改变可能通过多种方式引起。在比特币出现的前两年，中本聪通过释放后向兼容的版本改变强制立即使用新规则，进行过多次的软分叉。许多像 `BIP30 <https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki>`__ 这样的软分叉是通过在代码中预先编码指定的一个固定时间或区块高度实现的。这种通过指定固定日期进行分叉的方式称为 :term:`用户发起软分叉（User Activated Soft Forks） <UASF>` (UASF)，它依靠大量的用户节点强制在指定日期后使新规则生效。

后续的软分叉会等待网络大部分算力（75%或95%）认可使用新的一致性规则。一旦超过认可阈值，所有的节点都会使用新的规则。这种依赖矿工进行分叉的方式称为 :term:`矿工发起软分叉（Miner Activated Soft Forks） <MASF>` (MASF)。

**资源:** `BIP16 <https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki>`__, `BIP30 <https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki>`__, 和 `BIP34 <https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki>`__ 被实现为可能导致软分叉的更改。 `BIP50 <https://github.com/bitcoin/bips/blob/master/bip-0050.mediawiki>`__ 描述了通过临时降级升级节点的功能来解决的意外硬分叉，以及在删除临时降级时有意使用的硬分叉。Gavin Andresen 的一份文件概述了 `如何实现未来的规则更改 <https://gist.github.com/gavinandresen/2355445>`__.

检测分叉
---------------

未升级的节点可能在这两种类型的分叉过程中使用和分发不正确的信息，从而产生可能导致财务损失的几种情况。特别地，未升级的节点可以中继和接受被升级的节点认为无效的交易，因此永远不会成为公认的最佳块链的一部分。未升级的节点也可能拒绝中继已经添加到或即将添加到最佳块链的块或交易，从而提供不完整的信息。

比特币核心包括通过查看区块链工作量证明来检测硬分叉的代码。如果未升级的节点接收到块链报头，该块链报头证明比其认为有效的最佳链多至少六个块的工作量证明，该节点在 `“getnetworkinfo” RPC <../reference/rpc/getnetworkinfo.html>`__ 结果中报告警告，并运行 ``-alertnotify`` 命令（如果已设置）。这会警告操作员，未升级的节点无法切换到可能是最好的区块链。

完整节点还可以检查块和交易版本号。如果在最近的几个块中看到的块或交易版本号高于节点使用的版本号，它可以假设它没有使用当前的共识规则。比特币核心通过 `“getnetworkinfo” RPC <../reference/rpc/getnetworkinfo.html>`__ 和 ``-alertnotify`` 命令（如果设置）报告这种情况。

在任何一种情况下，如果区块和交易数据来自一个显然没有使用当前共识规则的节点，则不应依赖这些数据。连接到完整节点的SPV客户端可以检测到可能的硬分叉，方法是连接到几个完整节点，并确保它们都在同一条链上，具有相同的块高度，加上或减去几个块，以考虑传输延迟和陈旧块。如果出现分歧，客户端可以断开与具有较弱链的节点的连接。

SPV客户端还应监控区块和 :ref:`交易版本号 <term-transaction-version-number>` 的增加，以确保他们处理收到的交易，并使用当前的共识规则创建新的交易。
